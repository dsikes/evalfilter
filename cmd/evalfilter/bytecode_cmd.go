package main

import (
	"flag"
	"fmt"
	"io/ioutil"

	"github.com/skx/evalfilter/v2"
)

// Structure for our options and state.
type bytecodeCmd struct {
	// Disable the bytecode optimizer
	raw bool
}

// Info returns the name of this subcommand.
func (b *bytecodeCmd) Info() (string, string) {
	return "bytecode", `Show the generated bytecode from a given script file.

This sub-command lexes, parses, and compiles the specified script,
then outputs the bytecode which has been produced.

Optionally you can disable the bytecode-optimizer to compare the
compiled results with and without that.

Example:

  $ evalfilter bytecode -no-optimizer script.in
  $ evalfilter bytecode script.in

`
}

// Arguments adds per-command args to the object.
func (b *bytecodeCmd) Arguments(f *flag.FlagSet) {
	f.BoolVar(&b.raw, "no-optimizer", false, "Disable the bytecode optimizer")

}

// Show the bytecode of the given script.
func (b *bytecodeCmd) Run(file string) {

	//
	// Read the file contents.
	//
	dat, err := ioutil.ReadFile(file)
	if err != nil {
		fmt.Printf("Error reading file %s - %s\n", file, err.Error())
		return
	}

	//
	// Create the evaluator.
	//
	eval := evalfilter.New(string(dat))

	var flags []byte
	if b.raw {
		flags = append(flags, evalfilter.NoOptimize)
	}

	//
	// Prepare
	//
	err = eval.Prepare(flags)

	if err != nil {
		fmt.Printf("Error compiling:%s\n", err.Error())
		return
	}

	//
	// Show the bytecode
	//
	err = eval.Dump()
	if err != nil {
		fmt.Printf("Failed to dump script: %s\n", err.Error())
		return
	}

}

// Execute is invoked if the user specifies `bytecode` as the subcommand.
func (b *bytecodeCmd) Execute(args []string) int {

	//
	// For each file we've been passed; run it.
	//
	for _, file := range args {
		b.Run(file)
	}

	return 0

}
